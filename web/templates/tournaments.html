<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>{{T "tournaments.title" .Lang}}</title>
        <link rel="stylesheet" href="/common.css">
        <link rel="icon" type="image/svg+xml" href="/favicon.svg">
        <script src="/common.js"></script>
        <script src="/table-filters.js"></script>
    </head>
    <body class="page-table">
        <nav class="top-nav">
            <div class="nav-container">
                <a href="/?lang={{.Lang}}" class="nav-brand">
                    <span class="logo">ü•è‚û°Ô∏èüóìÔ∏è</span>
                    <span class="brand-text">{{T "app.name" .Lang}}</span>
                </a>
                <div class="nav-links">
                    <a href="/tournaments?lang={{.Lang}}" class="active">{{T "nav.tournaments" .Lang}}</a>
                    <a href="/registrations?lang={{.Lang}}">{{T "nav.registrations" .Lang}}</a>
                </div>
                <div class="nav-actions">
                    <a href="/calendar/edit?lang={{.Lang}}">{{T "nav.access_calendar" .Lang}}</a>
                    <a href="/calendar/new?lang={{.Lang}}" class="primary">{{T "nav.create_calendar" .Lang}}</a>
                </div>
                {{template "lang-switcher" .}}
                <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">‚ò∞</button>
            </div>
        </nav>
        <div class="main-content">
            <div class="page-header">
                <div class="page-header-left">
                    <h1>{{T "tournaments.title" .Lang}}</h1>
                    <p class="sync-info">
                        <span class="sync-indicator" id="sync-indicator"></span>
                        <span id="sync-text">Last synced: {{ .LastSync }}</span>
                        <span id="sync-time" data-iso="{{ .LastSyncISO }}" style="display:none;"></span>
                    </p>
                </div>
                <button class="filters-toggle" onclick="toggleFilters()" data-show-text="{{T "filter.show_filters" .Lang}}" data-hide-text="{{T "filter.hide_filters" .Lang}}">
                    <svg class="filter-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/></svg>
                    <span class="filter-text">{{T "filter.show_filters" .Lang}}</span>
                    <span class="toggle-icon">‚ñº</span>
                </button>
            </div>
            <div class="filters-container">
                <div class="filters-row">
                    <div class="filter-item-wide">
                        <label class="filter-label">{{T "filter.search" .Lang}}</label>
                        <input type="text" id="filter-search" class="filter-input" placeholder="{{T "filter.search_placeholder" .Lang}}">
                    </div>

                    <div class="filter-item-wide">
                        <label class="filter-label">{{T "filter.series" .Lang}}</label>
                        <select id="filter-series-dropdown" class="filter-select-small" onchange="addSeriesFilter()">
                            <option value="">{{T "filter.series_placeholder" .Lang}}</option>
                        </select>
                        <div class="filter-tags" id="series-tags"></div>
                    </div>

                    <div class="filter-item-wide">
                        <label class="filter-label">{{T "filter.pdga_tier" .Lang}}</label>
                        <select id="filter-pdga-dropdown" class="filter-select-small" onchange="addPdgaFilter()">
                            <option value="">{{T "filter.pdga_tier_placeholder" .Lang}}</option>
                        </select>
                        <div class="filter-tags" id="pdga-tags"></div>
                    </div>

                    <div class="filter-item-wide">
                        <label class="filter-label">{{T "filter.month" .Lang}}</label>
                        <select id="filter-month-dropdown" class="filter-select-small" onchange="addMonthFilter()">
                            <option value="">{{T "filter.month_placeholder" .Lang}}</option>
                        </select>
                        <div class="filter-tags" id="month-tags"></div>
                    </div>

                    <div class="filter-item">
                        <label class="filter-label">{{T "filter.year" .Lang}}</label>
                        <select id="filter-year" class="filter-select">
                            <option value="all">{{T "filter.all" .Lang}}</option>
                        </select>
                    </div>

                    <div class="filter-item">
                        <label class="filter-label">{{T "filter.drating" .Lang}}</label>
                        <select id="filter-drating" class="filter-select">
                            <option value="all">{{T "filter.all" .Lang}}</option>
                            <option value="yes">{{T "filter.yes" .Lang}}</option>
                            <option value="no">{{T "filter.no" .Lang}}</option>
                        </select>
                    </div>

                    <div class="filter-item">
                        <label class="filter-label">{{T "filter.sort" .Lang}}</label>
                        <select id="filter-sort" class="filter-select">
                            <option value="asc">{{T "filter.earliest_first" .Lang}}</option>
                            <option value="desc">{{T "filter.latest_first" .Lang}}</option>
                        </select>
                    </div>

                    <div class="filter-item">
                        <label class="filter-label">&nbsp;</label>
                        <button id="reset-filters" class="filter-reset-btn">{{T "filter.reset_all" .Lang}}</button>
                    </div>
                </div>
            </div>

        <div class="table-container">
            <table id="tournaments-table">
            <tbody>
                {{range $groupIndex, $group := .Groups}}
                    {{if gt $groupIndex 0}}
                    <tr class="tournament-year-divider">
                        <td colspan="3">
                            <div class="divider-line"></div>
                            <div class="divider-text">{{$group.Year}}</div>
                        </td>
                    </tr>
                    {{end}}
                    {{range $group.Tournaments}}
                    {{$tournamentId := .Id}}
                    <tr data-title="{{.Title}}" data-series="{{join .Series ","}}" data-pdga="{{.PdgaTier}}" data-drating="{{if .DRating}}yes{{else}}no{{end}}" data-month="{{.StartDate.Format "2006-01"}}" data-date="{{.StartDate.Format "2006-01-02"}}" data-year="{{.StartDate.Format "2006"}}">
                        <td data-sort-value="{{.StartDate.Format "2006-01-02"}}">
                            {{template "date-range" (dict "Start" .StartDate "End" .EndDate "Lang" $.Lang)}}
                            {{$tournament := .}}
                            <div class="reg-status-list">
                                {{if .HasActiveRegistration}}
                                <a href="https://turniere.discgolf.de/index.php?p=events&sp=register&id={{.Id}}" target="_blank" class="reg-item open">{{if and .HasMultiplePhases .ActiveRegistrationTitle}}<span class="reg-phase">{{.ActiveRegistrationTitle}}</span>{{end}}<span class="reg-timing">{{T "tournaments.registration_open" $.Lang}}&nbsp;‚Üó</span></a>
                                {{end}}
                                {{range .UpcomingRegistrations}}
                                <span class="reg-item {{if .OpensToday}}today{{else if or .OpensTomorrow (eq .OpensInDays 1)}}tomorrow{{else}}upcoming{{end}}">{{if $tournament.HasMultiplePhases}}{{if .Title}}<span class="reg-phase">{{.Title}}</span>{{end}}{{end}}<span class="reg-timing">{{if .OpensToday}}{{TArgs "tournaments.reg_opens_today" $.Lang (.StartTime.Format "15:04")}}{{else if or .OpensTomorrow (eq .OpensInDays 1)}}{{TArgs "tournaments.reg_opens_tomorrow" $.Lang (.StartTime.Format "15:04")}}{{else}}{{TArgs "tournaments.reg_opens_in_days" $.Lang .OpensInDays}}{{end}}</span></span>
                                {{end}}
                                {{if and (not .HasActiveRegistration) (not .UpcomingRegistrations)}}
                                <span class="reg-item status-{{.Status | lower}}">{{TStatus .Status $.Lang}}</span>
                                {{end}}
                            </div>
                        </td>
                        <td>
                            <a href="/tournament/{{.Id}}?lang={{$.Lang}}">{{.Title}}</a>
                            {{if .Localtion}}
                            <div class="tournament-location">
                                {{if .GeoLocation}}
                                <a href="https://www.openstreetmap.org/search?query={{.GeoLocation}}" target="_blank" class="location-link">{{.Localtion}} <span class="link-icon">‚Üó</span></a>
                                {{else}}
                                {{.Localtion}}
                                {{end}}
                            </div>
                            {{end}}
                        </td>
                        <td>
                            <div class="badges-cell">
                                {{range .Series}}
                                <a href="https://turniere.discgolf.de/index.php?p=events&sp=view&id={{$tournamentId}}" target="_blank" class="info-badge series-badge">{{.}} <span class="link-icon">‚Üó</span></a>
                                {{end}}
                                {{if .PdgaTier}}
                                    {{if .PdgaId}}
                                    <a href="https://www.pdga.com/tour/event/{{.PdgaId}}" target="_blank" class="info-badge pdga-badge">{{.PdgaTier}}-Tier <span class="link-icon">‚Üó</span></a>
                                    {{else}}
                                    <span class="info-badge pdga-badge">{{.PdgaTier}}-Tier</span>
                                    {{end}}
                                {{end}}
                                {{if .DRating}}
                                <span class="info-badge drating-badge">{{T "tournament.drating" $.Lang}}</span>
                                {{end}}
                            </div>
                        </td>
                    </tr>
                    {{end}}
                {{end}}
            </tbody>
        </table>
        </div>
        </div>
        <script>
            // Translations for sync time
            const i18n = {
                justNow: '{{T "time.just_now" .Lang}}',
                minuteAgo: '{{T "time.minute_ago" .Lang}}',
                minutesAgo: '{{T "time.minutes_ago" .Lang}}',
                hourAgo: '{{T "time.hour_ago" .Lang}}',
                hoursAgo: '{{T "time.hours_ago" .Lang}}',
                dataUpdated: '{{T "time.data_updated" .Lang}}'
            };

            // Sync time display
            function updateSyncTime() {
                const syncTimeEl = document.getElementById('sync-time');
                const syncTextEl = document.getElementById('sync-text');
                const syncIndicator = document.getElementById('sync-indicator');

                if (!syncTimeEl || !syncTimeEl.dataset.iso) return;

                const syncDate = new Date(syncTimeEl.dataset.iso);
                const now = new Date();
                const diffMs = now - syncDate;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMins / 60);

                let relativeText;
                if (diffMins < 1) {
                    relativeText = i18n.justNow;
                    syncIndicator.className = 'sync-indicator fresh';
                } else if (diffMins === 1) {
                    relativeText = i18n.minuteAgo;
                    syncIndicator.className = 'sync-indicator fresh';
                } else if (diffMins < 60) {
                    relativeText = i18n.minutesAgo.replace('{0}', diffMins);
                    syncIndicator.className = diffMins < 30 ? 'sync-indicator fresh' : 'sync-indicator recent';
                } else if (diffHours === 1) {
                    relativeText = i18n.hourAgo;
                    syncIndicator.className = 'sync-indicator recent';
                } else if (diffHours < 24) {
                    relativeText = i18n.hoursAgo.replace('{0}', diffHours);
                    syncIndicator.className = 'sync-indicator stale';
                } else {
                    relativeText = syncDate.toLocaleDateString();
                    syncIndicator.className = 'sync-indicator stale';
                }

                syncTextEl.textContent = i18n.dataUpdated.replace('{0}', relativeText);
            }

            // Initialize table filters
            let tableFilter;
            let seriesSet;
            let pdgaSet;
            const selectedSeries = new Set();
            const selectedPdga = new Set();
            const selectedMonths = new Set();
            const monthsData = new Map(); // Store value -> display mapping

            // Generate 12 months starting from current month
            function getNext12Months() {
                const months = [];
                const now = new Date();
                const currentYear = now.getFullYear();
                const currentMonth = now.getMonth(); // 0-11

                for (let i = 0; i < 12; i++) {
                    const date = new Date(currentYear, currentMonth + i, 1);
                    const yearMonth = date.getFullYear() + '-' + String(date.getMonth() + 1).padStart(2, '0');
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    const displayName = monthNames[date.getMonth()] + (date.getFullYear() > currentYear ? ' ' + date.getFullYear() : '');
                    months.push({ value: yearMonth, display: displayName });
                }
                return months;
            }

            // Function to update year divider visibility
            function updateYearDividers() {
                const dividers = document.querySelectorAll('.tournament-year-divider');
                dividers.forEach(divider => {
                    // Find all tournament rows between this divider and the next divider (or end of table)
                    let nextRow = divider.nextElementSibling;
                    let hasVisibleTournaments = false;

                    while (nextRow && !nextRow.classList.contains('tournament-year-divider')) {
                        const style = window.getComputedStyle(nextRow);
                        if (style.display !== 'none') {
                            hasVisibleTournaments = true;
                            break;
                        }
                        nextRow = nextRow.nextElementSibling;
                    }

                    // Hide divider if no tournaments are visible in this year group
                    divider.style.display = hasVisibleTournaments ? '' : 'none';
                });
            }

            // URL query parameter handling
            function updateUrlParams() {
                const params = new URLSearchParams();

                // Preserve lang parameter
                const currentParams = new URLSearchParams(window.location.search);
                if (currentParams.has('lang')) {
                    params.set('lang', currentParams.get('lang'));
                }

                // Search
                const searchValue = document.getElementById('filter-search').value.trim();
                if (searchValue) params.set('search', searchValue);

                // Series (multi-select)
                if (selectedSeries.size > 0) {
                    params.set('series', Array.from(selectedSeries).join(','));
                }

                // PDGA tier (multi-select)
                if (selectedPdga.size > 0) {
                    params.set('pdga', Array.from(selectedPdga).join(','));
                }

                // Month (multi-select)
                if (selectedMonths.size > 0) {
                    params.set('month', Array.from(selectedMonths).join(','));
                }

                // Year
                const yearValue = document.getElementById('filter-year').value;
                if (yearValue !== 'all') params.set('year', yearValue);

                // D-Rating
                const dratingValue = document.getElementById('filter-drating').value;
                if (dratingValue !== 'all') params.set('drating', dratingValue);

                // Sort
                const sortValue = document.getElementById('filter-sort').value;
                if (sortValue !== 'asc') params.set('sort', sortValue);

                // Update URL without reload
                const newUrl = params.toString() ? `${window.location.pathname}?${params.toString()}` : window.location.pathname;
                window.history.replaceState({}, '', newUrl);
            }

            function loadFiltersFromUrl() {
                const params = new URLSearchParams(window.location.search);

                // Search
                const searchValue = params.get('search');
                if (searchValue) {
                    document.getElementById('filter-search').value = searchValue;
                    tableFilter.setFilterValue('search', searchValue);
                }

                // Series
                const seriesParam = params.get('series');
                if (seriesParam) {
                    seriesParam.split(',').forEach(value => {
                        if (seriesSet.has(value) && !selectedSeries.has(value)) {
                            selectedSeries.add(value);
                            // Remove from dropdown
                            const dropdown = document.getElementById('filter-series-dropdown');
                            for (let i = 1; i < dropdown.options.length; i++) {
                                if (dropdown.options[i].value === value) {
                                    dropdown.remove(i);
                                    break;
                                }
                            }
                        }
                    });
                    if (selectedSeries.size > 0) {
                        updateTagDisplay('series-tags', selectedSeries, removeSeriesFilter);
                        tableFilter.setFilterValue('series', true);
                    }
                }

                // PDGA tier
                const pdgaParam = params.get('pdga');
                if (pdgaParam) {
                    pdgaParam.split(',').forEach(value => {
                        if (pdgaSet.has(value) && !selectedPdga.has(value)) {
                            selectedPdga.add(value);
                            // Remove from dropdown
                            const dropdown = document.getElementById('filter-pdga-dropdown');
                            for (let i = 1; i < dropdown.options.length; i++) {
                                if (dropdown.options[i].value === value) {
                                    dropdown.remove(i);
                                    break;
                                }
                            }
                        }
                    });
                    if (selectedPdga.size > 0) {
                        updateTagDisplay('pdga-tags', selectedPdga, removePdgaFilter);
                        tableFilter.setFilterValue('pdga', true);
                    }
                }

                // Month
                const monthParam = params.get('month');
                if (monthParam) {
                    monthParam.split(',').forEach(value => {
                        if (monthsData.has(value) && !selectedMonths.has(value)) {
                            selectedMonths.add(value);
                            // Remove from dropdown
                            const dropdown = document.getElementById('filter-month-dropdown');
                            for (let i = 1; i < dropdown.options.length; i++) {
                                if (dropdown.options[i].value === value) {
                                    dropdown.remove(i);
                                    break;
                                }
                            }
                        }
                    });
                    if (selectedMonths.size > 0) {
                        updateTagDisplay('month-tags', selectedMonths, removeMonthFilter);
                        tableFilter.setFilterValue('month', true);
                    }
                }

                // Year
                const yearParam = params.get('year');
                if (yearParam) {
                    document.getElementById('filter-year').value = yearParam;
                    tableFilter.setFilterValue('year', yearParam);
                }

                // D-Rating
                const dratingParam = params.get('drating');
                if (dratingParam) {
                    document.getElementById('filter-drating').value = dratingParam;
                    tableFilter.setFilterValue('drating', dratingParam);
                }

                // Sort
                const sortParam = params.get('sort');
                if (sortParam) {
                    document.getElementById('filter-sort').value = sortParam;
                    tableFilter.sort(0, sortParam);
                }
            }

            document.addEventListener('DOMContentLoaded', function() {
                // Update sync time display
                updateSyncTime();
                setInterval(updateSyncTime, 60000);

                tableFilter = new TableFilter('#tournaments-table');

                // Set callback to update dividers after filtering
                tableFilter.onFilterChange = updateYearDividers;

                // Add search filter
                tableFilter.addFilter('search', {
                    value: '',
                    fn: (row, value) => {
                        if (!value) return true;
                        return row.dataset.title.toLowerCase().includes(value.toLowerCase());
                    }
                });

                // Add series filter
                tableFilter.addFilter('series', {
                    value: null,
                    fn: (row, value) => {
                        if (selectedSeries.size === 0) return true;
                        const rowSeries = row.dataset.series.split(',');
                        return Array.from(selectedSeries).some(s => rowSeries.includes(s));
                    }
                });

                // Add PDGA tier filter
                tableFilter.addFilter('pdga', {
                    value: null,
                    fn: (row, value) => {
                        if (selectedPdga.size === 0) return true;
                        return selectedPdga.has(row.dataset.pdga);
                    }
                });

                // Add year filter
                tableFilter.addFilter('year', {
                    value: 'all',
                    fn: (row, value) => {
                        if (value === 'all') return true;
                        return row.dataset.year === value;
                    }
                });

                // Add D-Rating filter
                tableFilter.addFilter('drating', {
                    value: 'all',
                    fn: (row, value) => {
                        if (value === 'all') return true;
                        return row.dataset.drating === value;
                    }
                });

                // Add month filter
                tableFilter.addFilter('month', {
                    value: null,
                    fn: (row, value) => {
                        if (selectedMonths.size === 0) return true;
                        return selectedMonths.has(row.dataset.month);
                    }
                });

                // Populate series dropdown
                seriesSet = new Set();
                tableFilter.rows.forEach(row => {
                    const series = row.dataset.series;
                    if (series) {
                        series.split(',').forEach(s => {
                            if (s.trim()) seriesSet.add(s.trim());
                        });
                    }
                });
                const seriesSelect = document.getElementById('filter-series-dropdown');
                Array.from(seriesSet).sort().forEach(series => {
                    const option = document.createElement('option');
                    option.value = series;
                    option.textContent = series;
                    seriesSelect.appendChild(option);
                });

                // Populate PDGA tier dropdown
                pdgaSet = new Set();
                tableFilter.rows.forEach(row => {
                    const pdga = row.dataset.pdga;
                    if (pdga) pdgaSet.add(pdga);
                });
                const pdgaSelect = document.getElementById('filter-pdga-dropdown');
                Array.from(pdgaSet).sort().forEach(pdga => {
                    const option = document.createElement('option');
                    option.value = pdga;
                    option.textContent = pdga + '-Tier';
                    pdgaSelect.appendChild(option);
                });

                // Populate month dropdown (next 12 months)
                const monthSelect = document.getElementById('filter-month-dropdown');
                const next12Months = getNext12Months();
                next12Months.forEach(month => {
                    monthsData.set(month.value, month.display);
                    const option = document.createElement('option');
                    option.value = month.value;
                    option.textContent = month.display;
                    monthSelect.appendChild(option);
                });

                // Populate year dropdown
                const yearSet = new Set();
                tableFilter.rows.forEach(row => {
                    const year = row.dataset.year;
                    if (year) yearSet.add(year);
                });
                const yearSelect = document.getElementById('filter-year');
                Array.from(yearSet).sort().forEach(year => {
                    const option = document.createElement('option');
                    option.value = year;
                    option.textContent = year;
                    yearSelect.appendChild(option);
                });

                // Load filters from URL params
                loadFiltersFromUrl();

                // Event listeners
                document.getElementById('filter-search').addEventListener('input', (e) => {
                    tableFilter.setFilterValue('search', e.target.value.trim());
                    updateUrlParams();
                });

                document.getElementById('filter-year').addEventListener('change', (e) => {
                    tableFilter.setFilterValue('year', e.target.value);
                    updateUrlParams();
                });

                document.getElementById('filter-drating').addEventListener('change', (e) => {
                    tableFilter.setFilterValue('drating', e.target.value);
                    updateUrlParams();
                });

                document.getElementById('filter-sort').addEventListener('change', (e) => {
                    tableFilter.sort(0, e.target.value);
                    updateUrlParams();
                });

                // Reset button
                document.getElementById('reset-filters').addEventListener('click', () => {
                    // Clear search
                    document.getElementById('filter-search').value = '';

                    // Clear tags
                    document.getElementById('series-tags').textContent = '';
                    document.getElementById('pdga-tags').textContent = '';
                    document.getElementById('month-tags').textContent = '';

                    // Restore all options to series dropdown
                    const seriesDropdown = document.getElementById('filter-series-dropdown');
                    while (seriesDropdown.options.length > 1) {
                        seriesDropdown.remove(1);
                    }
                    Array.from(seriesSet).sort().forEach(series => {
                        const option = document.createElement('option');
                        option.value = series;
                        option.textContent = series;
                        seriesDropdown.appendChild(option);
                    });

                    // Restore all options to PDGA dropdown
                    const pdgaDropdown = document.getElementById('filter-pdga-dropdown');
                    while (pdgaDropdown.options.length > 1) {
                        pdgaDropdown.remove(1);
                    }
                    Array.from(pdgaSet).sort().forEach(pdga => {
                        const option = document.createElement('option');
                        option.value = pdga;
                        option.textContent = pdga + '-Tier';
                        pdgaDropdown.appendChild(option);
                    });

                    // Restore all options to month dropdown
                    const monthDropdown = document.getElementById('filter-month-dropdown');
                    while (monthDropdown.options.length > 1) {
                        monthDropdown.remove(1);
                    }
                    const next12Months = getNext12Months();
                    next12Months.forEach(month => {
                        const option = document.createElement('option');
                        option.value = month.value;
                        option.textContent = month.display;
                        monthDropdown.appendChild(option);
                    });

                    // Clear selected sets
                    selectedSeries.clear();
                    selectedPdga.clear();
                    selectedMonths.clear();

                    // Reset other dropdowns
                    seriesDropdown.selectedIndex = 0;
                    pdgaDropdown.selectedIndex = 0;
                    monthDropdown.selectedIndex = 0;
                    document.getElementById('filter-year').value = 'all';
                    document.getElementById('filter-drating').value = 'all';
                    document.getElementById('filter-sort').value = 'asc';

                    tableFilter.reset();
                    updateUrlParams();
                });
            });

            // Safe helper to create filter tags without innerHTML
            function createFilterTag(displayText, onRemove) {
                const tag = document.createElement('span');
                tag.className = 'filter-tag';
                tag.appendChild(document.createTextNode(displayText + ' '));
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.textContent = '√ó';
                btn.addEventListener('click', onRemove);
                tag.appendChild(btn);
                return tag;
            }

            function addSeriesFilter() {
                const dropdown = document.getElementById('filter-series-dropdown');
                const selectedOption = dropdown.options[dropdown.selectedIndex];
                const value = dropdown.value.trim();

                if (value && !selectedSeries.has(value)) {
                    selectedSeries.add(value);
                    const tagsDiv = document.getElementById('series-tags');
                    const tag = createFilterTag(value, () => removeSeriesFilter(value));
                    tagsDiv.appendChild(tag);

                    // Remove the option from dropdown
                    selectedOption.remove();
                    dropdown.selectedIndex = 0;
                    tableFilter.setFilterValue('series', true);
                    updateUrlParams();
                }
            }

            function removeSeriesFilter(value) {
                selectedSeries.delete(value);
                updateTagDisplay('series-tags', selectedSeries, removeSeriesFilter);

                // Add the option back to dropdown
                const dropdown = document.getElementById('filter-series-dropdown');
                const option = document.createElement('option');
                option.value = value;
                option.textContent = value;

                // Insert in sorted order
                const options = Array.from(dropdown.options).slice(1); // Skip first placeholder
                options.push(option);
                options.sort((a, b) => a.value.localeCompare(b.value));

                // Clear and rebuild
                while (dropdown.options.length > 1) {
                    dropdown.remove(1);
                }
                options.forEach(opt => dropdown.add(opt));

                tableFilter.setFilterValue('series', true);
                updateUrlParams();
            }

            function addPdgaFilter() {
                const dropdown = document.getElementById('filter-pdga-dropdown');
                const selectedOption = dropdown.options[dropdown.selectedIndex];
                const value = dropdown.value.trim();

                if (value && !selectedPdga.has(value)) {
                    selectedPdga.add(value);
                    const tagsDiv = document.getElementById('pdga-tags');
                    const tag = createFilterTag(value + '-Tier', () => removePdgaFilter(value));
                    tagsDiv.appendChild(tag);

                    // Remove the option from dropdown
                    selectedOption.remove();
                    dropdown.selectedIndex = 0;
                    tableFilter.setFilterValue('pdga', true);
                    updateUrlParams();
                }
            }

            function removePdgaFilter(value) {
                selectedPdga.delete(value);
                updateTagDisplay('pdga-tags', selectedPdga, removePdgaFilter);

                // Add the option back to dropdown
                const dropdown = document.getElementById('filter-pdga-dropdown');
                const option = document.createElement('option');
                option.value = value;
                option.textContent = value + '-Tier';

                // Insert in sorted order
                const options = Array.from(dropdown.options).slice(1);
                options.push(option);
                options.sort((a, b) => a.value.localeCompare(b.value));

                // Clear and rebuild
                while (dropdown.options.length > 1) {
                    dropdown.remove(1);
                }
                options.forEach(opt => dropdown.add(opt));

                tableFilter.setFilterValue('pdga', true);
                updateUrlParams();
            }

            function addMonthFilter() {
                const dropdown = document.getElementById('filter-month-dropdown');
                const selectedOption = dropdown.options[dropdown.selectedIndex];
                const value = dropdown.value.trim();

                if (value && !selectedMonths.has(value)) {
                    selectedMonths.add(value);
                    const tagsDiv = document.getElementById('month-tags');
                    const display = monthsData.get(value);
                    const tag = createFilterTag(display, () => removeMonthFilter(value));
                    tagsDiv.appendChild(tag);

                    // Remove the option from dropdown
                    selectedOption.remove();
                    dropdown.selectedIndex = 0;
                    tableFilter.setFilterValue('month', true);
                    updateUrlParams();
                }
            }

            function removeMonthFilter(value) {
                selectedMonths.delete(value);
                updateTagDisplay('month-tags', selectedMonths, removeMonthFilter);

                // Add the option back to dropdown
                const dropdown = document.getElementById('filter-month-dropdown');
                const option = document.createElement('option');
                option.value = value;
                option.textContent = monthsData.get(value);

                // Insert back maintaining order (months are already in chronological order)
                const allMonths = Array.from(monthsData.keys());
                const currentOptions = Array.from(dropdown.options).slice(1);
                const allOptions = [...currentOptions, option];
                allOptions.sort((a, b) => allMonths.indexOf(a.value) - allMonths.indexOf(b.value));

                // Clear and rebuild
                while (dropdown.options.length > 1) {
                    dropdown.remove(1);
                }
                allOptions.forEach(opt => dropdown.add(opt));

                tableFilter.setFilterValue('month', true);
                updateUrlParams();
            }

            function updateTagDisplay(tagsDivId, selectedSet, removeFn) {
                const tagsDiv = document.getElementById(tagsDivId);
                tagsDiv.textContent = '';
                selectedSet.forEach(value => {
                    let display = value;
                    if (tagsDivId === 'pdga-tags') display = value + '-Tier';
                    if (tagsDivId === 'month-tags') display = monthsData.get(value);
                    const tag = createFilterTag(display, () => removeFn(value));
                    tagsDiv.appendChild(tag);
                });
            }
        </script>
        {{template "footer" .}}
    </body>
</html>
